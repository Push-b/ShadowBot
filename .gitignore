node_modules
session
logs
.env
yarn.lock
package-lock.json




const YT = require('../../lib/YT3');
const yts = require('yt-search');

module.exports = {
    name: 'testing',
    aliases: ['d'],
    category: 'media',
    react: "âœ…",
    usage: 'Use :ytaudio <song_link>',
    description: 'Downloads given YouTube Video and sends it as Audio',
    async execute(client, arg, M) {
        try {
            const link = async (term) => {
                const { videos } = await yts(term.trim());
                if (!videos || !videos.length) return null;
                return videos[0];
            };

            if (!arg) return M.reply('Please use this command with a valid YouTube link');
            const linkData = await link(arg);
            const validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts)\/)/;
            const term = validPathDomains.test(arg) ? arg.trim() : linkData?.url;
            if (!term) return M.reply('Please use this command with a valid YouTube content link');

            M.reply(`ğŸ”Š Downloading: ${linkData?.title}`);

            // Check if the video is longer than 30 minutes
            if (Number(linkData.seconds) > 1800) return M.reply('âŒ Cannot download audio longer than 30 minutes');

            // Downloading and sending the audio
            const yt = await YT.ytmp3(term);

            if (!yt.status) {
                return M.reply(`âŒ Failed to download audio:\n${yt.error || 'Unknown error'}`);
            }

            await client.sendMessage(
                M.from,
                {
                    audio: yt.buffer,
                    mimetype: 'audio/mpeg',
                    ptt: false,
                    contextInfo: {
                        externalAdReply: {
                            title: yt.title || linkData.title,
                            body: "ğŸ¶ YouTube Audio",
                            thumbnail: yt.thumbnail || null,
                            mediaType: 2,
                            mediaUrl: term,
                            sourceUrl: term,
                            renderLargerThumbnail: true
                        }
                    }
                },
                { quoted: M }
            );
        } catch (error) {
            console.error(error);
            M.reply('âŒ An error occurred while downloading the YouTube video audio.');
        }
    }
};






const YT = require('../../lib/YT3');
const yts = require('yt-search');
const axios = require('axios');

module.exports = {
    name: 'testing',
    aliases: ['d'],
    category: 'media',
    react: "âœ…",
    usage: 'Use :ytaudio <song_link or name>',
    description: 'Downloads given YouTube Video and sends it as Audio with thumbnail & link',
    async execute(client, arg, M) {
        try {
            if (!arg) return M.reply('â— Please use this command with a YouTube link or song name.');

            const search = async (term) => {
                const { videos } = await yts(term.trim());
                return videos && videos.length ? videos[0] : null;
            };

            const validYT = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts|watch)\b)/;
            const isLink = validYT.test(arg.trim());
            const linkData = isLink ? null : await search(arg);
            const url = isLink ? arg.trim() : linkData?.url;

            if (!url) return M.reply('â— Failed to find or parse a valid YouTube link.');

            const info = isLink ? await search(url) : linkData;
            if (!info) return M.reply('â— Could not retrieve video details.');

            M.reply(`ğŸµ Downloading: *${info.title}*\nBy: *${info.author.name}*`);

            if (Number(info.seconds) > 1800)
                return M.reply('âŒ Cannot download audio longer than 30 minutes.');

            const yt = await YT.ytmp3(url);
            if (!yt.status) return M.reply(`âŒ Audio download failed:\n${yt.error || 'Unknown error'}`);

            // Fetch the thumbnail as a buffer
            const thumbBuffer = yt.thumbnail
                ? (await axios.get(yt.thumbnail, { responseType: 'arraybuffer' })).data
                : null;

            await client.sendMessage(
                M.from,
                {
                    audio: yt.buffer,
                    mimetype: 'audio/mpeg',
                    ptt: false,
                    contextInfo: {
                        externalAdReply: {
                            title: yt.title || info.title,
                            body: info.author.name || "YouTube Music",
                            thumbnail: thumbBuffer,
                            mediaType: 2,
                            mediaUrl: url,
                            sourceUrl: url,
                            renderLargerThumbnail: true
                        }
                    }
                },
                { quoted: M }
            );
        } catch (error) {
            console.error(error);
            M.reply('âŒ An unexpected error occurred while downloading the YouTube audio.');
        }
    }
};





const YT = require('../../lib/YT3');
const yts = require('yt-search');
const axios = require('axios');

module.exports = {
    name: 'ytvideo',
    aliases: ['ytv', 'video'],
    category: 'media',
    react: "ğŸ“½ï¸",
    usage: 'Use :ytvideo <YouTube link or song name>',
    description: 'Downloads a YouTube video (max 30 min) and sends it',
    async execute(client, arg, M) {
        try {
            if (!arg) return M.reply('â— Please provide a YouTube link or search term.');

            const search = async (term) => {
                const { videos } = await yts(term.trim());
                return videos && videos.length ? videos[0] : null;
            };

            const validYT = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts|watch)\b)/;
            const isLink = validYT.test(arg.trim());
            const linkData = isLink ? null : await search(arg);
            const url = isLink ? arg.trim() : linkData?.url;

            if (!url) return M.reply('â— Could not find a valid YouTube video.');

            const info = isLink ? await search(url) : linkData;
            if (!info) return M.reply('â— Could not retrieve video details.');

            if (Number(info.seconds) > 1800)
                return M.reply('âŒ Cannot download videos longer than 30 minutes.');

            M.reply(`ğŸ“¥ Downloading: *${info.title}*\nBy: *${info.author.name}*`);

            const yt = await YT.ytmp4(url);
            if (!yt.status) return M.reply(`âŒ Video download failed:\n${yt.error || 'Unknown error'}`);

            await client.sendMessage(
                M.from,
                {
                    video: yt.buffer,
                    mimetype: 'video/mp4',
                    fileName: `${yt.title}.mp4`,
                    caption: `ğŸ¬ *${yt.title}*\nğŸ“º ${info.author.name}\nğŸ”— ${url}`
                },
                { quoted: M }
            );
        } catch (error) {
            console.error(error);
            M.reply('âŒ An error occurred while downloading the YouTube video.');
        }
    }
};





const yts = require('yt-search');
const YT = require('../../lib/YT3');

module.exports = {
    name: 'ytalbum',
    aliases: ['album', 'ytplaylist'],
    category: 'media',
    usage: 'ytalbum <playlist URL or album name>',
    description: 'Downloads up to 10 songs from a YouTube album/playlist as audio',
    react: "ğŸ¶",

    async execute(client, arg, M) {
        try {
            if (!arg) return M.reply("â— Please provide a playlist URL or album name.");

            let playlist;

            if (arg.includes("list=")) {
                playlist = await yts({ listId: arg.split("list=")[1].split("&")[0] });
            } else {
                const search = await yts(arg);
                const firstPlaylist = search.playlists?.[0];
                if (!firstPlaylist) return M.reply("âŒ No playlist or album found.");
                playlist = await yts({ listId: firstPlaylist.listId });
            }

            if (!playlist || !playlist.videos.length)
                return M.reply("âŒ Could not retrieve playlist contents.");

            const songs = playlist.videos.slice(0, 10); // â›” LIMIT TO 10 SONGS
            await M.reply(`ğŸ“€ *Album:* ${playlist.title}\nğŸ§ Sending first *${songs.length}* tracks...\n\nâ³ Please wait, downloading...`);

            const cooldownMs = 5000; // 5 seconds cooldown

            for (let i = 0; i < songs.length; i++) {
                const track = songs[i];

                if (Number(track.seconds) > 1800) {
                    await M.reply(`âš ï¸ Skipping: *${track.title}* (over 30 mins)`);
                    continue;
                }

                try {
                    const audio = await YT(track.url, 'audio');
                    await client.sendMessage(
                        M.from,
                        {
                            document: audio,
                            mimetype: 'audio/mpeg',
                            fileName: `${track.title}.mp3`
                        },
                        { quoted: M }
                    );

                    if (i !== songs.length - 1) {
                        await new Promise(res => setTimeout(res, cooldownMs));
                    }
                } catch (err) {
                    console.log(`âŒ Error sending: ${track.title}`, err);
                    await M.reply(`âŒ Failed to send: *${track.title}*`);
                }
            }

            await M.reply("âœ… Finished sending up to 10 tracks from the album.");
        } catch (err) {
            console.error(err);
            M.reply("âŒ An error occurred while processing the album.");
        }
    }
};
